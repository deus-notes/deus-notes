~~~~~~~~~~~~~~~~~~TMP~~~~~~~~~~~~~~~~~~~~

eBPF - современный тренд в мире профайлинга на Линукc.
eBPF - это виртуальная машина, которая может запускать юзерский байт код в различных местах ядра.
Его можно использовать как универсальная утилита трассирования ядра
    eBPF был содан для оптимизации фильтрования сетевых пакетов, если вы запустите tcpdump - то ваши матчеры будут
скомпилированы в BPF bytecode который будет запущен в JIT.
    Неоспоримым плюсом и отличием eBPF от loadable kernel modules состоит в том, что eBPF не может присести к
кернел крашу, поскольку оно будет запускать только безопасный код.
    eBPF программы являются байткодом, который передается в виртуальную машину на выполнение. И виртуальная машина
запустит данный код только в том случае, если он пройдет верификацию.Например, проверку на то, что в коде нет
доступа к невалидной памяти, нет бесконечных циклов и т.п.
    Однако eBPF программы не обязательно писать только на bytecode, создатели предоставили инструмен для написания
eBPF программ на привычной нам С. Дальше llvm превратит наш C код в eBPF объектный файл, который может использоваться
в ядре.
eBPF имеет широкий выбор точек для выполнение. К примеру, программа может быть выполнена на kprobe, uprobe, ftrace_hook,
tracepoints (https://github.com/iovisor/bcc/blob/master/docs/reference_guide.md#events--arguments)

eBPF делится на несколько компонентов:
1. backend часть - байткод, который работает в виртуальном пространстве в ядре.
2. loader - загрузчик байт кода, он передает код программы на верификацию. Обычно, время жизни backend == времени жизни loader.
3. frontend - userspace часть eBPF программы, которая ответственна за получение данных из ядра через data structures
4. data structures - Некий механизм, который используется чтобы предоставить канал коммуникации между
backend и frontend.

eBPF - это виртуальная машина, которая использует 64 битные RISK подобный инструкции состаящие из работающих
JIT eBPF программ.

Ограничения: циклы запрещенны (но есть workaround)

Цикл запуск eBPF программы:
1. Userspace отправляет bytecode в ядро вместе с типом программы, из которой ядро сможет понять, 
какие области должны быть доступны
2. Ядро запускает верификатор eBPF программ, который проверяет что программа безопасна kernel/bpf/verifier.c
3. JIT компилирует bytecode в nativecode и вставляет его в нужное место
4. Программа пишет инфу в кольцевой буффер или в мапу
5. Userspace читает результат

Для упрощения работы с eBPF ядро предоставляет библиотеку libbpf

можно использовать bpf_override_return для того, чтобы перегрузить захуканую функцию и вызвать stub,
который ничего не делает кроме того, что возвращает значение rc

eBPF виртуальная машина использует 11 64 битных регистров.
r0: Используется для возвращаемого значениея как eBPF программы, так и вызова kernel функции
??r1-r5: Определяют аргументы вызванной функции, где r1 - контекст программы
TODO: r6-r9: 

Как выглядит типичная программа:
TODO:
1. Создание мапы
2. Запись байт кода с помощью макросов в bpf_insn структуру
3. загрузка байт кода
4. юзерспейс работа

Cпособы облегчить себе жизнь:
1. Писать backend используя LLVM eBPF compiler
2. Использовать bcc компилятор
3. bpfftrace
